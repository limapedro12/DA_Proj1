<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA: Programming Project I: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA: Programming Project I
   </div>
   <div id="projectbrief">An Analysis Tool for Runway Network Management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A graph class for a railway network.  
 <a href="class_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1e8942f364b93d5159e3bd1e1f9419af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_station.html">Station</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1e8942f364b93d5159e3bd1e1f9419af">findVertex</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a1e8942f364b93d5159e3bd1e1f9419af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc27ac68f38db42927a37000f331ac06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adc27ac68f38db42927a37000f331ac06">addVertex</a> (<a class="el" href="class_station.html">Station</a> *station)</td></tr>
<tr class="separator:adc27ac68f38db42927a37000f331ac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab59f1701276ce3848cfe8dd5fdff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adaab59f1701276ce3848cfe8dd5fdff1">removeEdge</a> (<a class="el" href="class_station.html">Station</a> *orig, <a class="el" href="class_station.html">Station</a> *dest, bool alfa)</td></tr>
<tr class="separator:adaab59f1701276ce3848cfe8dd5fdff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e89bc15a96ae21124d98e50098cf008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3e89bc15a96ae21124d98e50098cf008">addEdge</a> (<a class="el" href="class_station.html">Station</a> *sourc, <a class="el" href="class_station.html">Station</a> *dest, double w, bool alfa)</td></tr>
<tr class="separator:a3e89bc15a96ae21124d98e50098cf008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c774c3c9f7a80767faf07a5bda37cb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2c774c3c9f7a80767faf07a5bda37cb1">addBidirectionalEdge</a> (<a class="el" href="class_station.html">Station</a> *sourc, <a class="el" href="class_station.html">Station</a> *dest, double w, bool alfa)</td></tr>
<tr class="separator:a2c774c3c9f7a80767faf07a5bda37cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fbd1e7697703ce92a11ff3dd1f2cf3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_station.html">Station</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a35fbd1e7697703ce92a11ff3dd1f2cf3">getVertexSet</a> () const</td></tr>
<tr class="separator:a35fbd1e7697703ce92a11ff3dd1f2cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fee14432bc7154a1e5899c1fce9303"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a15fee14432bc7154a1e5899c1fce9303">path</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *dest) const</td></tr>
<tr class="separator:a15fee14432bc7154a1e5899c1fce9303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838661806d669f4e0d4190050d8b836e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a838661806d669f4e0d4190050d8b836e">findBottleneck</a> (std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; <a class="el" href="class_graph.html#a15fee14432bc7154a1e5899c1fce9303">path</a>)</td></tr>
<tr class="separator:a838661806d669f4e0d4190050d8b836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2eb148fb2d027ff956901af7401203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acc2eb148fb2d027ff956901af7401203">edmondsKarp</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *target)</td></tr>
<tr class="separator:acc2eb148fb2d027ff956901af7401203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be1d113d6106ed0664630d7443da8a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1be1d113d6106ed0664630d7443da8a1">maxFlow</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *target, bool print=false)</td></tr>
<tr class="separator:a1be1d113d6106ed0664630d7443da8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523a45dd9302d2a675784d3899f5487b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a523a45dd9302d2a675784d3899f5487b">maxTrainsAtStation</a> (<a class="el" href="class_station.html">Station</a> *destStation)</td></tr>
<tr class="separator:a523a45dd9302d2a675784d3899f5487b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7742ac91471da9d4497811fe9cbcfe07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7742ac91471da9d4497811fe9cbcfe07">pathDijkstra</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *dest) const</td></tr>
<tr class="separator:a7742ac91471da9d4497811fe9cbcfe07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4649163c3c86589abedbdffb36dc7f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5b4649163c3c86589abedbdffb36dc7f">minCost</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *target)</td></tr>
<tr class="separator:a5b4649163c3c86589abedbdffb36dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9610a4992e419580d6b8a460085d9d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae9610a4992e419580d6b8a460085d9d5">edmondsKarpMinCost</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *target, double costLimit)</td></tr>
<tr class="separator:ae9610a4992e419580d6b8a460085d9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3e9b17ff4e2993a622666ccad8a2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a59f3e9b17ff4e2993a622666ccad8a2c">cost</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *target, bool print=false)</td></tr>
<tr class="separator:a59f3e9b17ff4e2993a622666ccad8a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1ca8a7c2e44e4e220d7596fd6f0e3b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9f1ca8a7c2e44e4e220d7596fd6f0e3b">maxTrainsMinCost</a> (<a class="el" href="class_station.html">Station</a> *source, <a class="el" href="class_station.html">Station</a> *target, double costLimit, bool print=false)</td></tr>
<tr class="separator:a9f1ca8a7c2e44e4e220d7596fd6f0e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7096c2e6aef509ac6724ac835ba90c0b"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; <a class="el" href="class_station.html">Station</a> *, <a class="el" href="class_station.html">Station</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7096c2e6aef509ac6724ac835ba90c0b">mostTrainsPair</a> ()</td></tr>
<tr class="separator:a7096c2e6aef509ac6724ac835ba90c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad371a5688f996b1948e847f75e73e477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad371a5688f996b1948e847f75e73e477">printFlow</a> ()</td></tr>
<tr class="separator:ad371a5688f996b1948e847f75e73e477"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a53f59f1ad52b5ef4d39cca44e7d25d0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a53f59f1ad52b5ef4d39cca44e7d25d0c">costBFS</a> (<a class="el" href="class_station.html">Station</a> *source)</td></tr>
<tr class="separator:a53f59f1ad52b5ef4d39cca44e7d25d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae3bd6f9b25e62a99a66639d72dda499b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_station.html">Station</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae3bd6f9b25e62a99a66639d72dda499b">vertexSet</a></td></tr>
<tr class="separator:ae3bd6f9b25e62a99a66639d72dda499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A graph class for a railway network. </p>
<p >The <a class="el" href="class_graph.html" title="A graph class for a railway network.">Graph</a> class is the "main" class of the program, since it contains all the objects that model the railway network. It also comprehends all the algorithms necessary to perform the desired operations and calculations. As stated in other places, the graph's nodes/vertexes are objects of the <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> class, each one containing their adjacent railway segments, represented by the <a class="el" href="class_edge.html" title="A class that represents a railway segment between two Stations, being an Edge of the network graph.">Edge</a> class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2c774c3c9f7a80767faf07a5bda37cb1" name="a2c774c3c9f7a80767faf07a5bda37cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c774c3c9f7a80767faf07a5bda37cb1">&#9670;&#160;</a></span>addBidirectionalEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tries to add a bidirectional edge with ends on the desired stations, with the desired wheight and type of segment. The method does this by adding two edges, one from sourc to dest and another from dest to sourc.</p>
<p >Time Complexity: O(1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>Pointer to the origin <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> (this and dest are interchangeable) </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> (this and sourc are interchangeable) </td></tr>
    <tr><td class="paramname">w</td><td>Weight of the segment (capacity in terms of number of trains it can handle simultaneously) </td></tr>
    <tr><td class="paramname">alfa</td><td>Whether the segment is of type STANDARD (false) or ALFA PENDULAR (true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="class_edge.html" title="A class that represents a railway segment between two Stations, being an Edge of the network graph.">Edge</a> is added, false otherwise (if one or more of the Stations is/are not found). </dd></dl>

</div>
</div>
<a id="a3e89bc15a96ae21124d98e50098cf008" name="a3e89bc15a96ae21124d98e50098cf008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e89bc15a96ae21124d98e50098cf008">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">Edge</a> * Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds an edge to the sourc <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> adjacent edges leading to the dest <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a>, with the desired weight and type of segment.</p>
<p >Time Complexity: O(1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>Pointer to the origin <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to the destination <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> </td></tr>
    <tr><td class="paramname">w</td><td>Weight of the segment (capacity in terms of number of trains it can handle simultaneously) </td></tr>
    <tr><td class="paramname">alfa</td><td>Whether the segment is of type STANDARD (false) or ALFA PENDULAR (true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly added <a class="el" href="class_edge.html" title="A class that represents a railway segment between two Stations, being an Edge of the network graph.">Edge</a>, nullptr if one or more of the Stations is/are not found </dd></dl>

</div>
</div>
<a id="adc27ac68f38db42927a37000f331ac06" name="adc27ac68f38db42927a37000f331ac06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc27ac68f38db42927a37000f331ac06">&#9670;&#160;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>station</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tries to add a vertex (<a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> pointer) to the graph's vertex set, checking if it already exists.</p>
<p >Time complexity: O(1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station</td><td>Pointer to the <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> pointer is added, false if already is part of the vertex set </dd></dl>

</div>
</div>
<a id="a59f3e9b17ff4e2993a622666ccad8a2c" name="a59f3e9b17ff4e2993a622666ccad8a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3e9b17ff4e2993a622666ccad8a2c">&#9670;&#160;</a></span>cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::cost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Uses the <a class="el" href="class_graph.html#ae9610a4992e419580d6b8a460085d9d5">edmondsKarpMinCost()</a> method without cost limit(i.e. with the costLimit set to numeric_limits&lt;double&gt;::max()) to find residual graph associated with a certain source and destination vertex. Then, it uses the residual graph to find the the cost of the network running at its maximum capacity from the source to the destination. For that it uses the method <a class="el" href="class_graph.html#a53f59f1ad52b5ef4d39cca44e7d25d0c">costBFS()</a> to find the cost of the residual graph. It also has a boolean parameter, which if true, prints all the paths in the residual graph which have a flow greater than 0(<a class="el" href="class_graph.html#ad371a5688f996b1948e847f75e73e477">printFlow()</a>).</p>
<p >Time Complexity: O(V*E^2*log(V)), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
    <tr><td class="paramname">print</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cost of the network running at its maximum capacity from the source to the destination </dd></dl>

</div>
</div>
<a id="a53f59f1ad52b5ef4d39cca44e7d25d0c" name="a53f59f1ad52b5ef4d39cca44e7d25d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f59f1ad52b5ef4d39cca44e7d25d0c">&#9670;&#160;</a></span>costBFS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::costBFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Private method that returns the cost of a graph, which is the sum of the cost of all the edges in the graph with a flow greater than 0.</p>
<p >Time Complexity: O(V+E), where V is the number of stations and E is the number of edges in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cost of the graph </dd></dl>

</div>
</div>
<a id="acc2eb148fb2d027ff956901af7401203" name="acc2eb148fb2d027ff956901af7401203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2eb148fb2d027ff956901af7401203">&#9670;&#160;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::edmondsKarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Runs the Edmonds-Karp algorithm to find the maximum flow from a source vertex to a destination vertex. For that this method uses the <a class="el" href="class_graph.html#a15fee14432bc7154a1e5899c1fce9303">path()</a> method to find the path with the least amount of edges. Returns the residual graph after the algorithm has finished.</p>
<p >Time Complexity: O(V*E^2), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the residual graph </dd></dl>

</div>
</div>
<a id="ae9610a4992e419580d6b8a460085d9d5" name="ae9610a4992e419580d6b8a460085d9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9610a4992e419580d6b8a460085d9d5">&#9670;&#160;</a></span>edmondsKarpMinCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::edmondsKarpMinCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>costLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Runs a variation of Edmonds-Karp algorithm to find the maximum flow from a source vertex to a destination vertex The variation is that the algorithm uses the Dijkstra Algorithm to find the augmentation paths, instead of the BFS, so that the residual graph obtained is the residual graph with the lowest possible cost, and stops when the cost of the path is greater than a given cost limit. For that this method uses the <a class="el" href="class_graph.html#a7742ac91471da9d4497811fe9cbcfe07">pathDijkstra()</a> method to find the path with the lowest cost. Returns the residual graph after the algorithm has finished.</p>
<p >Time Complexity: O(V*E^2*log(V)), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
    <tr><td class="paramname">costLimit</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum flow from the source to the destination </dd></dl>

</div>
</div>
<a id="a838661806d669f4e0d4190050d8b836e" name="a838661806d669f4e0d4190050d8b836e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838661806d669f4e0d4190050d8b836e">&#9670;&#160;</a></span>findBottleneck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::findBottleneck </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a path, returns the bottleneck of that path, which is the minimum capacity of all the edges in the path.</p>
<p >Time Complexity: O(P), where P is the number of edges in the path</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bottleneck of that path </dd></dl>

</div>
</div>
<a id="a1e8942f364b93d5159e3bd1e1f9419af" name="a1e8942f364b93d5159e3bd1e1f9419af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8942f364b93d5159e3bd1e1f9419af">&#9670;&#160;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_station.html">Station</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds a <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> (vertex) in the graph's vertex set.</p>
<p >Time complexity: O(V) where V is the number of stations(vertices) in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> to be found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the desired <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a>, nullptr if the station is not found </dd></dl>

</div>
</div>
<a id="a35fbd1e7697703ce92a11ff3dd1f2cf3" name="a35fbd1e7697703ce92a11ff3dd1f2cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fbd1e7697703ce92a11ff3dd1f2cf3">&#9670;&#160;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_station.html">Station</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="class_graph.html" title="A graph class for a railway network.">Graph</a>'s vertex set getter.</p>
<p >Time Complexity: O(1).</p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the std::vector&lt;Station*&gt; vertexSet. </dd></dl>

</div>
</div>
<a id="a1be1d113d6106ed0664630d7443da8a1" name="a1be1d113d6106ed0664630d7443da8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be1d113d6106ed0664630d7443da8a1">&#9670;&#160;</a></span>maxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::maxFlow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Uses the <a class="el" href="class_graph.html#acc2eb148fb2d027ff956901af7401203">edmondsKarp()</a> method to find residual graph associated with a certain source and destination vertex. Then, it uses the residual graph to find the maximum flow from the source to the destination. For that it sums the flow of all the edges leaving the source vertex. It also has a boolean parameter, which if true, prints all the paths in the residual graph which have a flow greater than 0(<a class="el" href="class_graph.html#ad371a5688f996b1948e847f75e73e477">printFlow()</a>).</p>
<p >Time Complexity: O(V*E^2), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
    <tr><td class="paramname">print</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum flow from the source to the destination </dd></dl>

</div>
</div>
<a id="a523a45dd9302d2a675784d3899f5487b" name="a523a45dd9302d2a675784d3899f5487b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523a45dd9302d2a675784d3899f5487b">&#9670;&#160;</a></span>maxTrainsAtStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::maxTrainsAtStation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>destStation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method creates a new temporary graph, which is a copy of the original graph. Then it adds a new vertex to the temporary graph, which will be the source vertex. After that we add a new edge from the temporary vertex to each vertex in the original graph, except the destination vertex. Then we run the Edmonds-Karp algorithm(edmondsKarp() method) on the temporary graph, with the temporary vertex as the source and the destination vertex as the destination, and we return the maximum flow found.</p>
<p >Time Complexity: O(V*E^2), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destStation</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of trains that can simultaneously arrive at a given station, taking into consideration the entire railway grid. </dd></dl>

</div>
</div>
<a id="a9f1ca8a7c2e44e4e220d7596fd6f0e3b" name="a9f1ca8a7c2e44e4e220d7596fd6f0e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1ca8a7c2e44e4e220d7596fd6f0e3b">&#9670;&#160;</a></span>maxTrainsMinCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int, double &gt; Graph::maxTrainsMinCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>costLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Uses the <a class="el" href="class_graph.html#ae9610a4992e419580d6b8a460085d9d5">edmondsKarpMinCost()</a> method to find residual graph associated with a certain source and destination vertex and specified cost limit. Then, it uses the residual graph to find the the flow from the source to the destination in the residual graph and the number of trains that can be sent from the source to the destination without exceeding the cost limit. For the flow it sums the flow of all the edges leaving the source vertex, and for the cost it iterates through all the edges in the residual graph and sums the cost of all the edges with a flow greater than 0. It also has a boolean parameter, which if true, prints all the paths in the residual graph which have a flow greater than 0(<a class="el" href="class_graph.html#ad371a5688f996b1948e847f75e73e477">printFlow()</a>).</p>
<p >Time Complexity: O(V*E^2*log(V)), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
    <tr><td class="paramname">costLimit</td><td></td></tr>
    <tr><td class="paramname">print</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5b4649163c3c86589abedbdffb36dc7f" name="a5b4649163c3c86589abedbdffb36dc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4649163c3c86589abedbdffb36dc7f">&#9670;&#160;</a></span>minCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; Graph::minCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Runs the Dijkstra algorithm to find the minimum cost from a source vertex to a destination vertex. For that this method uses the <a class="el" href="class_graph.html#a7742ac91471da9d4497811fe9cbcfe07">pathDijkstra()</a> method to find the path with the lowest cost. Returns the minimum cost and the corresponding path.</p>
<p >Time Complexity: O((V+E)*log(V)), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">target</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum cost and the corresponding path </dd></dl>

</div>
</div>
<a id="a7096c2e6aef509ac6724ac835ba90c0b" name="a7096c2e6aef509ac6724ac835ba90c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7096c2e6aef509ac6724ac835ba90c0b">&#9670;&#160;</a></span>mostTrainsPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::pair&lt; <a class="el" href="class_station.html">Station</a> *, <a class="el" href="class_station.html">Station</a> * &gt; &gt; Graph::mostTrainsPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15fee14432bc7154a1e5899c1fce9303" name="a15fee14432bc7154a1e5899c1fce9303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fee14432bc7154a1e5899c1fce9303">&#9670;&#160;</a></span>path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; Graph::path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a vector of <a class="el" href="class_edge.html" title="A class that represents a railway segment between two Stations, being an Edge of the network graph.">Edge</a> pointers with the path from a source vertex to a destination vertex, which has the least amount of Edges. For that it uses the BFS algorithm to find the path.</p>
<p >Time Complexity: O(V+E), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of <a class="el" href="class_edge.html" title="A class that represents a railway segment between two Stations, being an Edge of the network graph.">Edge</a> </dd></dl>

</div>
</div>
<a id="a7742ac91471da9d4497811fe9cbcfe07" name="a7742ac91471da9d4497811fe9cbcfe07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7742ac91471da9d4497811fe9cbcfe07">&#9670;&#160;</a></span>pathDijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; Graph::pathDijkstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a vector of <a class="el" href="class_edge.html" title="A class that represents a railway segment between two Stations, being an Edge of the network graph.">Edge</a> pointers with the path from a source vertex to a destination vertex, which has the lowest cost. For this it uses the Dijkstra algorithm, but instead of a priority queue it uses a set.</p>
<p >Time Complexity: O((V+E)*log(V)), where V is the number of stations and E is the number of edges in the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td></td></tr>
    <tr><td class="paramname">dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad371a5688f996b1948e847f75e73e477" name="ad371a5688f996b1948e847f75e73e477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad371a5688f996b1948e847f75e73e477">&#9670;&#160;</a></span>printFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::printFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints the origin, the destination and the flow of all the edges in the graph, which have a flow greater than 0.</p>
<p >Time Complexity: O(V+E), where V is the number of stations and E is the number of edges in the graph. </p>

</div>
</div>
<a id="adaab59f1701276ce3848cfe8dd5fdff1" name="adaab59f1701276ce3848cfe8dd5fdff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaab59f1701276ce3848cfe8dd5fdff1">&#9670;&#160;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::removeEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tries to remove an <a class="el" href="class_edge.html" title="A class that represents a railway segment between two Stations, being an Edge of the network graph.">Edge</a> (railway segment) whose ends are in the desired stations and is of the desired type (STANDARD/ALFA).</p>
<p >Time Complexity: O(degree(v)), where degree(v) is the number of edges leaving the origin vertex v</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>Pointer to one of the segment ends <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to one of the segment ends <a class="el" href="class_station.html" title="A class that represents a Station, being a node of the network graph.">Station</a> </td></tr>
    <tr><td class="paramname">alfa</td><td>Whether the segment to remove is of type STANDARD (false) or ALFA PENDULAR (true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bool if removal is successful, false otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae3bd6f9b25e62a99a66639d72dda499b" name="ae3bd6f9b25e62a99a66639d72dda499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3bd6f9b25e62a99a66639d72dda499b">&#9670;&#160;</a></span>vertexSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_station.html">Station</a> *&gt; Graph::vertexSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >vector of pointers to all station(vertices) in the graph </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Pedro/CLionProjects/DA_Proj1/Classes/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/Users/Pedro/CLionProjects/DA_Proj1/Classes/<a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
